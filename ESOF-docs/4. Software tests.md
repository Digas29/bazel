# Relatório 4 - Testes de Software #

**Conteúdos**
- [Testes de Software](#relatório-4---testes-de-software)
	- [Introdução](#introdução)
	- [Grau de Testabilidade](#grau-de-testabilidade)
	- [Estatísticas de Teste](#estatísticas-de-teste)
	- [Correção do *Bug*](#correção-do-bug)
	- [Referências](#referências)
	- [Contribuições](#contribuições)
	- [Autores](#autores)


## Introdução ##

O sucesso do *software* depende muito do processo de testes. Testar um sistema com casos de teste definidos e avaliar os seus resultados é o primeiro passo para aumentar a confiança no *software* e avaliar a qualidade do produto.

No caso específico do *Bazel*, os principais recursos são intensivamente testados. Os testes usados, juntamente com uso intensivo por parte da *Google*, garantem atualmente uma versão estável.

É importante perceber que os testes permitem descobrir a existência de falhas, no entanto, não provam a não existência delas.

## Grau de Testabilidade ##

Esta propriedade extrínseca indica o grau de testabilidade que um determinado *software* suporta. Quanto maior for a capacidade de teste, mais fácil é encontrar falhas no sistema.

Apesar do *Bazel* ser utilizado para definir automaticamente testes unitários em várias linguagens, é também alvo de testes, que validam e verificam a sua funcionalidade.

O Bazel é, resumidamente, um compilador. Para testar as componentes separadamente é relativamente simples, pois não existe uma componente gráfica complexa (apenas linha de comandos). Assim, basta verificar que o output é igual ao resultado esperado sem ser preciso nenhuma interação com o utilizador (ao contrário do teste de algumas funções dos jogos). Contudo, o Bazel, na sua versão final, irá comunicar com as componentes em conjunto. Por conseguinte, é necessário fazer testes em conjunto em que um teste começa num componente e estende-se a outro. Veja-se o exemplo da linha de comandos ter uma comunicação bidirecional com a *Java Native Interface*. Concluindo, testar o comportamento das componentes em conjunto acaba por se revelar uma tarefa um pouco complicada.

### Controlabilidade ###

Representa o grau de possibilidade de controlo do componente sob teste (CUT - *Component Under Test*).

Aqui, tendo em conta a complexidade do *Bazel*, a controlabilidade depende do componente que nos queiramos referimos.

As componentes se testadas separadamente são relativamente simples de controlar (CUT - Component Under Test). O grau de dificuldade prende-se principalmente com o grau de entendimento que o programador tem com o programa. Assim, para um programador que acompanhou o progresso do *software* desde o início terá mais facilidade. Contudo, existem componentes que são mais difíceis de controlar por dependerem de ficheiros externos do utilizador. Neste caso, o programador tem de testar variados casos de teste para verificar a sua operabilidade em vez de testar só os casos principais. Atenta-se o exemplo: o Bazel pretende compilar grandes (e complexos) projetos em diversas linguagens de programação, assim é preciso testar todas estas combinações (C++ e Java, só Java, só C, entre outros).

### Observabilidade ###

Através da observabilidade, sabe-se o grau de possibilidade para determinar os resultados intermédios e finais dos testes.

Os resultados dos testes obtêm-se através da compilação em ambiente Linux ou Mac. É possível correr os *scripts* para os testes unitários no Eclipse e no IntelliJ e analisar facilmente os resultados obtidos.

Para um *pull request* ser aceite pelo master, é preciso que o código (funções) feito tenha vários casos de teste [Patch Acceptance Process](http://bazel.io/contributing.html) e que não altere negativamente o funcionamento global do programa. Deste modo, as futuras funções a ser implementadas podem ser feitas sabendo que o código base está certo e se os testes falharem, então alguma das novas funções está a alterar negativamente o comportamento do programa. Como o Bazel ainda está numa fase beta, então a cada *pull request* são executados todos os testes unitários de novo.

### Isolabilidade ###

A isolabilidade representa o grau com que cada componente (CUT) pode ser testado isoladamente.

No Bazel, as componentes comunicam entre si, logo é difícil isolar uma componente das restantes. Contudo, é possível testar as funções que cada componente deve fazer dentro de si sem necessidade de componentes externos como saber quais foram os ficheiros modificados e, consequentemente, necessitam de ser compilados. Assim, a componente sob teste (CUT) apenas pode ser testada parcialmente para ser de maneira isolada.

### Separação de responsabilidades ###

A separação de responsabilidades é importante para determinar se o componente sob teste (CUT) tem uma responsabilidade única, bem definida.

Foi estudado no relatório anterior a estrutura do Bazel e da maneira como estava organizado. Cada componente tem responsabilidades bem definidas. As componentes só comunicam entre si quando necessário, pois a eficácia é crucial neste projeto. Assim, as responsabilidades de cada componente são:
- Command-Line Interface (C++): interface com o utilizador na linha de comandos. É responsável por lidar com os pedidos do utilizador e executa os respetivos pedidos através da comunicação com outras componentes.
- [Protocol Buffers](https://developers.google.com/protocol-buffers/?hl=pt-PT): permite a utilização de várias linguagens de programação (neste caso C++ e Java) através da definição das mesmas estruturas.
- [Java Native Interface](https://en.wikipedia.org/wiki/Java_Native_Interface): interface de comunicação entre C++ e Java. É responsável por "converter" os pedidos de uma linguagem para a outra (bidirecional).
- Core: componente mais importante do Bazel. É responsável por saber quais os ficheiros que necessitam de ser compilados e, se necessário, recompilar.

### Inteligibilidade ###

Através deste fator, obtemos o grau com que cada componente sob teste é documentado e autoexplicativo.

### Heterogeneidade ###

Determina o grau que o uso de diversas tecnologias requer para usar diversos métodos de ensaio e ferramentas em paralelo.

## Estatísticas de Teste ##

As estatísticas resultam de casos de testes representativos para estimar o valor de uma métrica de qualidade de *software*. Determinam a eficiência e a fiabilidade do sistema. No Bazel, o código aceite tem que obedecer a [condições rigorosas](http://bazel.io/governance.html#core-contributors) em que só é aceite código bem escrito e testado (este escrutínio pode não acontecer em casos excecionais).

### Testes unitários ###



### Testes de integração ###



### Testes de sistema ###



### Testes de aceitação ###

Como já referimos em relatórios anteriores, o cliente deste produto é o próprio programador. Já discutimos as vantagens inerentes, como por exemplo estar definido desde o início o que o programador/cliente pretende. Assim, no nosso caso não são necessários *acceptance tests*, pois o Bazel é contruído pelos clientes.

### Testes de regressão ###

Sempre que uma alteração é proposta, um *core contributor* fica responsável por testá-la e avaliá-la. Uma das suas preocupações é que esta alteração não provoque erros nas restantes funções implementadas. Assim, a execução de testes de uma parte seletiva é sempre feita a cada importante alteração (como *pull requests* por exemplo).

## Correção do *Bug* ##

Known Issues

The version of the Closure Templates compiler that is used will emit warnings about protected property access and about a missing enum value. These issues have been fixed in the source, but are not yet available as a downloadable archive. These warnings are safe to ignore.

You may define a newlocalrepository target if you wish to check out the source from Github yourself. Otherwise you may wish to wait until the Closure tools are available as Bazel workspaces. e.g.

```
new_local_repository(
    name = "closure_templates",
    build_file = "tools/build_rules/closure/closure_templates.BUILD",
    path = "/home/user/src/github/google/closure-templates/target",
)
```

ou

Procurar no LINK ISSUES


## Referências ##

* Página oficial: http://bazel.io/
* Problemas: https://github.com/bazelbuild/bazel/issues
* FAQs: http://bazel.io/faq.html

## Contribuições ##
* António Ramadas: 2 horas.
* João Guarda: 2 horas.
* Rui Vilares: 2 horas.
* Trabalho em grupo: 4 horas.

## Autores ##

Turma 1 - Grupo 4

* [António Manuel Vieira Ramadas](https://github.com/antonio-ramadas)
* [João Diogo Trindade Guarda](https://github.com/Digas29)
* [Rui Miguel Teixeira Vilares](https://github.com/RuiVilares)

[Engenharia de Software (ESOF)](https://sigarra.up.pt/feup/pt/ucurr_geral.ficha_uc_view?pv_ocorrencia_id=368707)

Faculdade de Engenharia da Universidade do Porto

22 de novembro de 2015
